# Тестирование

Одним из самых главных преимуществ чистой архитектуры является то, что мы можем покрыть тестами намного больший функционал приложения за счет разбиения кода на мелкие классы, каждый из которых выполняет строго определенную задачу. Благодаря принципу инверсии зависимостей, используемому в чистой архитектуре мы можем с легкостью подменять реализацию тех или иных классов на фейковые, которые реализуют нужное нам поведение.

Прежде чем начать писать тесты, мы должны ответить себе на два вопроса:

- что мы хотим тестировать?
- как мы будем это тестировать?

Что мы хотим тестировать:

- Мы хотим проверить нашу бизнес-логику независимо от какого-либо фреймворка или библиотеки.
- Мы хотим протестировать нашу интеграцию с API.
- Мы хотим протестировать нашу интеграцию с нашей системой персистентности.
- Все, что содержит условия.

Что мы НЕ должны тестировать:

- Сторонние библиотеки (мы предполагаем, что они работают правильно, потому что уже протестированы разработчиками)
- Тривиальный код (например, геттеры и сеттеры)

Теперь, давайте разберём то, как мы будем тестировать каждый из слоев.

## Тестирование слоя представления

Данный слой включает в себя 2 типа тестов:  Unit-тесты и UI-тесты.

- Unit-тесты используются для тестирования Presenter'ов.
- UI-тесты используются для тестирования Activity (проверяется корректность отображения элементов и т. д.).

Существуют различные соглашения по именованию тестовых методов. Например, в этой [статье](https://dzone.com/articles/7-popular-unit-test-naming) описаны некоторые из них. В примерах, которые я буду приводить далее, я не буду придерживаться какого-либо соглашения. Самое главное понять из названия, что тестирует наш метод и что мы хотим получить в результате. 

Давайте рассмотрим пример теста для **ArticlesListPresenter**:

```kotlin
class ArticlesListPresenterTest {

    @Test
    fun shouldLoadArticlesOnViewAttached() {
        //preparing
        val interactor = Mockito.mock(ArticlesListInteractor::class.java)
        val schedulers = TestSchedulersProvider()
        val presenter = ArticlesListPresenter(interactor, schedulers)
        val view = Mockito.mock(ArticlesListView::class.java)

        val articlesList = ArrayList<Article>
        `when`(interactor.getArticlesList()).thenReturn(Single.just(articlesList))

        //testing
        presenter.attachView(view)

        //asserting
        verify(view, times(1)).showLoadingProgress(true)
        verify(view, times(1)).showLoadingProgress(false)
        verify(view, times(1)).showArticles(articlesList)
    }

}
```

Как видите, мы разделили код теста на три части:

- Подготовка к тестированию. Здесь мы инициализируем объекты для тестирования, подготавливаем тестовые данные, а также предопределяем поведение моков.
- Само тестирование. 
- Проверка результатов тестирования. Здесь мы проверяем, что у View были вызваны нужные методы и переданы аргументы.

## Тестирование бизнес-логики

В данном слое тестируюится классы Interactor'ов и Entity. Необходимо проверить, действительно ли бизнес-логика реализует требуемое поведение .

[раздел на доработке]

## Тестирование слоя работы с данными

[раздел на доработке]