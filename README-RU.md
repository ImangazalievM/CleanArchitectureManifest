![CleanArchitectureManifest](https://raw.githubusercontent.com/ImangazalievM/CleanArchitectureManifest/master/images/CleanArchitectureManifest.png)

# Clean Architecture Manifest (v. 0.9.5)

Здесь вы найдете описание основных принципов и правил, которыми стоит руководствоваться при разработке Android-приложений с использованием чистой архитектуры. 

**Translations:**

[English](/README.md) | [Русский](/README-RU.md)

Если вы хотите перевести этот документ на свой язык, пожалуйста посетите [эту страницу](contributing.md).

## Содержание

- [Введение](#Введение)
- [Слои и инверсия зависимостей](#Слои-и-инверсия-зависимостей)
- [Разбиение классов по пакетам](#Разбиение-классов-по-пакетам)
- [Дополнительные сущности, используемые на практике](#Дополнительные-сущности-используемые-на-практике)
- [Обработка ошибок](#Обработка-ошибок)
- [Тестирование](#Тестирование)
- [Перенос на Clean Architecture существующих проектов](#Перенос-на-clean-architecture-существующих-проектов)
- [FAQ по Clean Architecture](#faq-по-clean-architecture)

## Введение

Clean Achitecture — способ построения архитектуры приложения, [предложенный](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) Робертом Мартином (который также известен как дядюшка Боб - Uncle Bob) в 2012 году. 

Clean Architecture включает в себя два основных принципа:

1. **Разделение на слои** 
2. **Инверсия зависимостей**

Давайте расшифруем каждый из них.

**Разделение на слои**

Суть принципа заключается в разделении всего кода приложения на слои. Всего мы имеем три слоя: 

- слой отображения
- слой бизнес логики
- слой работы с данными

Самым главным слоем является слой бизнес логики. Особенность данного слоя заключается в том, что он не зависит ни от каких внешних библиотек или фреймворков. Это достигается за счет *инверсии зависимостей*.

**Инверсия зависимостей**

Согласно данному принципу слой бизнес-логики не должен зависеть от внешних. То есть классы из внешних слоев не должны использоваться в классах бизнес-логики. Взаимодействие с внешними слоями происходит через интерфейсы, которые реализуют классы внешних слоев. 

Благодаря разделению ответственности между классами мы легко можем изменять код приложения, а также добавлять новый функционал, затрагивая при этом минимальное количество классов. Помимо этого мы получаем легко тестируемый код. Стоит заметить, что построение правильной архитектуры целиком и полностью зависит от самого разработчика и его опыта.

Преимущества чистой архитектуры:

- независимость от UI, БД и фреймворков
- позволяет быстрее добавлять новые функции
- более высокий процент покрытия кода тестами
- повышенная простота навигации по структуре пакетов

Недостатки чистой архитектуры:

- большое количество классов
- довольно высокий порог вхождения и, зачастую, неправильное понимание на первых порах

**Внимание:** перед прочтением данного документа, настоятельно рекомендую ознакомиться  со следующими темами (иначе, вы ничего не поймете):

- Dagger 2
- RxJava 2

Очень желательно, чтобы у вас был практический опыт их использования, так вы быстрее войдете в курс дела. Если вы уже знакомы с ними, то можете смело приступать к прочтению. Всё объяснение темы Clean Architecture будет строиться вокруг новостного приложения, которое мы, в теории, хотели бы создать.

**P. S.** Я разработал приложение, чтобы продемонстрировать использование чистой архитектуры на практике. Исходный код вы можете найти здесь - [Bubbble](https://github.com/ImangazalievM/Bubbble).

### Эта статья была полезна для вас? ❤️

- Поддержите её нажав на кнопку ⭐️ в верху этой страницы. ✌️